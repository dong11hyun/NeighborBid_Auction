# 🚀 배포 초보자를 위한 상세 분석 가이드

> **이 가이드의 목적**:  
> 앞서 본 `2_1확장성_런칭_vps_aws.md` 파일에서 "그냥 복사해서 붙여넣으세요"라고 했던 명령어들이  
> **도대체 무슨 뜻인지**, **왜 필요한지**, **내 서버에서 무슨 일을 벌이는지** 하나하나 뜯어서 설명해 드립니다.

---

## 📚 목차

1. [Step 4: Docker 설치 명령어 완전 분해](#1-step-4-docker-설치-명령어-완전-분해)
2. [Step 6 & 7: docker-compose.prod.yml 코드 해부](#2-step-6--7-docker-composeprodyml-코드-해부)
3. [마무리: 전체 그림 다시 보기](#3-마무리-전체-그림-다시-보기)

---

# 1. Step 4: Docker 설치 명령어 완전 분해

서버(컴퓨터)를 처음 샀을 때는 아무것도 없는 "빈 깡통" 상태입니다.  
여기에 우리가 요리(앱 실행)를 할 수 있도록 **주방(Docker)**을 설치하는 과정입니다.

### 1️⃣ 시스템 업데이트
```bash
sudo apt update && sudo apt upgrade -y
```
- **`sudo`**: "관리자 권한으로 실행해!" (SuperUser DO). 리눅스는 보안이 철저해서 중요 작업은 허락을 받아야 합니다.
- **`apt update`**: "설치 가능한 프로그램 목록을 최신으로 갱신해." (앱스토어 새로고침 같은 것)
- **`&&`**: "앞의 명령어가 성공하면, 뒤의 명령어도 실행해."
- **`apt upgrade -y`**: "내 컴퓨터에 깔린 프로그램들을 최신 버전으로 업데이트해. (`-y`: 묻지 말고 Yes)"

### 2️⃣ Docker 설치 스크립트 다운로드 및 실행
```bash
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
```
- **`curl`**: 인터넷에서 파일을 다운로드하는 도구.
- **`https://get.docker.com`**: 도커 설치 파일이 있는 주소.
- **`-o get-docker.sh`**: 다운로드한 파일을 `get-docker.sh`라는 이름으로 저장해라.
- **`sudo sh get-docker.sh`**: 방금 받은 스크립트(`get-docker.sh`)를 실행(`sh`)해서 도커를 설치 시작!

### 3️⃣ Docker Compose 설치
```bash
sudo apt install docker-compose-plugin -y
```
- **Docker**: 주방 그 자체 (컨테이너 실행 환경).
- **Docker Compose**: 여러 요리(DB, 웹서버, Redis 등)를 **한 번에** 준비하는 "세트 메뉴 주문서".
- 이 명령어로 `docker compose` 명령어를 쓸 수 있게 됩니다.

### 4️⃣ 권한 부여 (중요!)
```bash
sudo usermod -aG docker ubuntu
```
- 리눅스는 기본적으로 `sudo`를 붙여야 도커를 쓸 수 있습니다.
- "매번 `sudo docker` 치기 귀찮으니까, `ubuntu`라는 내 계정도 도커를 맘대로 쓰게 해줘(`-aG docker`)" 라는 뜻입니다.
- 이 설정을 적용하려면 **로그아웃 후 다시 접속**해야 합니다.

---

# 2. Step 6 & 7: docker-compose.prod.yml 코드 해부

이 파일은 **"우리 서비스의 설계도"**입니다.  
서버에게 *"이 설계도대로 건물(서비스)을 지어줘"*라고 명령하면, 알아서 DB도 깔고, 웹서버도 띄워줍니다.

파일 전체를 서비스별로 쪼개서 설명해 드릴게요.

## 🏗️ 전체 구조 (Services)
이 파일에는 5개의 주인공(서비스)이 등장합니다.
1.  **db**: 데이터 저장소 (PostgreSQL)
2.  **redis**: 임시 저장소 및 채팅용 우편함
3.  **web**: 우리가 만든 Django 웹사이트
4.  **nginx**: 경비실 및 안내 데스크 (웹 서버)
5.  **certbot**: 보안 자물쇠(HTTPS) 발급 담당

---

## 🔎 1. db (데이터베이스)
```yaml
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "127.0.0.1:5432:5432"
    restart: always
```
- **`image: postgres:15-alpine`**: "직접 설치하지 말고, 이미 만들어진 가볍고(`alpine`) 튼튼한 포스트그레 15버전 이미지를 가져와."
- **`environment`**: DB를 켤 때 필요한 비밀번호 등을 설정합니다. `${...}`는 `.env` 파일에서 가져온다는 뜻입니다. (보안!)
- **`volumes`**: **★가장 중요!** 컨테이너(Docker)는 껐다 켜면 데이터가 사라질 수 있습니다. 그래서 **"데이터는 `postgres_data`라는 안전한 금고(볼륨)에 따로 저장해라"**라고 연결하는 것입니다.
- **`ports`**: `127.0.0.1:5432:5432` → 외부 해커가 DB에 직접 접속 못 하게, **서버 내부(Localhost)에서만** 접속 가능하게 막아두는 보안 설정입니다.

---

## 🔎 2. web (우리의 Django 앱)
```yaml
  web:
    build:
      context: .
      dockerfile: Dockerfile.prod
    environment:
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      ... (생략) ...
      - DB_HOST=db
      - REDIS_HOST=redis
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
```
- **`build`**: 남이 만든 이미지가 아니라, **우리가 짠 코드**로 직접 빌드합니다. `Dockerfile.prod`라는 요리법을 보고 만듭니다.
- **`environment`**:
    - `DB_HOST=db`: "데이터베이스가 어디 있어?" → "`db`라는 이름의 컨테이너를 찾아가." (Docker가 알아서 연결해줍니다)
    - `REDIS_HOST=redis`: "Redis는 어디 있어?" → "`redis` 컨테이너 찾아가."
- **`volumes`**:
    - `static_volume`: CSS, 이미지 같은 파일들을 한곳에 모아두는 바구니입니다. 나중에 Nginx가 가져다 씁니다.
    - `media_volume`: 사용자가 업로드한 사진 등을 저장하는 바구니입니다.
- **`depends_on`**: "DB랑 Redis가 켜져야 나도 켜질 수 있어." (순서 보장)

---

## 🔎 3. nginx (문지기)
```yaml
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
      - static_volume:/app/staticfiles
      - ... (인증서 관련)
    depends_on:
      - web
```
- **역할**: 사용자가 접속하면 가장 먼저 만나는 문지기입니다.
- **`ports`**:
    - `"80:80"`: `http://` 접속을 받아들임.
    - `"443:443"`: `https://` (보안) 접속을 받아들임.
    - 유일하게 **외부에 문(Port)을 열어두는** 녀석입니다.
- **`volumes`**:
    - `./nginx.conf`: 문지기 근무 수칙(설정 파일)을 전달합니다.
    - `static_volume`: 아까 `web`이 모아둔 CSS 파일 바구니를 공유받습니다. (Django보다 Nginx가 파일을 훨씬 빨리 보내주기 때문!)

---

## 🔎 4. metabase & certbot
- **metabase**: 데이터 시각화 도구. `db`에 연결해서 예쁜 그래프를 그려줍니다.
- **certbot**: 무료로 SSL(HTTPS 자물쇠) 인증서를 발급받고 갱신해주는 자동화 로봇입니다. 12시간마다 깨어나서 "인증서 만료 안 됐나?" 확인하고 다시 잠듭니다.

---

# 3. 마무리: 전체 그림 다시 보기

결국 `docker compose up` 명령어를 치는 순간 일어나는 일:

1.  **Docker**가 "설계도(`docker-compose.prod.yml`) 가져와!" 함.
2.  **DB, Redis**를 먼저 깨움 (데이터 저장소 준비).
3.  **Web(Django)**을 깨워서 코드를 실행함. 이때 DB랑 Redis에 연결함.
4.  **Web**이 "CSS, 이미지 파일 여기 모아둘게(`static_volume`)" 하고 짐을 쌈.
5.  **Nginx**가 깨어나서 대문을 엽니다(80, 443 포트). "이제 손님 받습니다!"
6.  손님이 오면 **Nginx**가 받아서 **Web**에게 "이 요청 처리해줘"라고 토스하거나, 이미지 파일은 직접 줍니다.

이 모든 과정이 명령어 한 줄로 끝나는 것이 바로 **Docker의 마법**입니다. 🧙‍♂️
